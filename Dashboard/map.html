<!-- Code from d3-graph-gallery.com -->
<!DOCTYPE html>
<meta charset="utf-8">
<!-- Load d3.js -->
<script src="http://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<!-- Create an element where the map will take place -->
<svg id="my_dataviz" width="800" height="600" ></svg>
<script>


var SHOW_COLORS = check_flag("mapColors"); // checkbox
var SHOW_HUBS = check_flag("hubs"); // checkbox

var year = sessionStorage.getItem("year");

var ANIMATION_SPEED = 50;
var COLOR_SCALE = d3.scaleLinear().domain([25, 70]).range(["white", "blue"]); // range of color

// The svg
var svg = d3.select("svg"),
  width = +svg.attr("width"),
  height = +svg.attr("height");

// Map and projection
var path = d3.geoPath();
var projection = d3.geoMercator()
    //The three lines bellow select the Europe zone;
  .center([ 13, 52 ])
  .scale([ width / 1.5 ])
  .translate([ width / 2, height / 2 ])

// Data and color scale
var data = d3.map();
var colorScale = d3.scaleThreshold()
  .domain([100000, 1000000, 10000000, 30000000, 100000000, 500000000])
  .range(d3.schemeBlues[8]);

// Loads GEO Data
d3.queue()
  //.defer(d3.json, "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson")
  .defer(d3.json, "/data/worldMapCountries.json")
  .defer(d3.csv, "/data/csvCleaned.csv", function(d) {data.set(d.ID, {"GEO" : d.GEO,
    "hub_2010" : +d.hub_2010,
    "hub_2011" : +d.hub_2011,
    "hub_2012" : +d.hub_2012,
    "hub_2013" : +d.hub_2013,
    "hub_2014" : +d.hub_2014,
    "hub_2015" : +d.hub_2014,
    "hub_2016" : +d.hub_2016,
    "hub_2017" : +d.hub_2017,
    "hub_2018" : +d.hub_2018,
    "hub_2019" : +d.hub_2019,
    "hub_2020" : +d.hub_2020,
    "itPop_2010" : +d.hrst_2010,
    "itPop_2011" : +d.hrst_2011,
    "itPop_2012" : +d.hrst_2012,
    "itPop_2013" : +d.hrst_2013,
    "itPop_2014" : +d.hrst_2014,
    "itPop_2015" : +d.hrst_2015,
    "itPop_2016" : +d.hrst_2016,
    "itPop_2017" : +d.hrst_2017,
    "itPop_2018" : +d.hrst_2018,
    "itPop_2019" : +d.hrst_2019,
    "itPop_2020" : +d.hrst_2020}
    );})
  .await(ready);

// Defines scale
function scale_size(value){
  var MAX_VAL = 0.5;
  var MIN_VAL = 0.0;
  var MAX_SIZE = 45;
  return (value*MAX_SIZE)/(MAX_VAL - MIN_VAL);
}

function check_flag(flag_name){
  var value = sessionStorage.getItem(flag_name);
  if (value === "true"){
    return true;
  } else {
    return false;
  }
}

function set_selected_country(countryID){
  sessionStorage.setItem("selectedCountry", countryID);
  var barchart = window.parent.document.getElementById("barchart");
  barchart.src = barchart.src;
}

function ready(error, topo) {
  let mouseOverCountry = function(d) {
    d3.selectAll(".Country")
      .filter(function(d) {
        return data.get(d.id);
      })
      .transition()
      .duration(ANIMATION_SPEED)
      .style("opacity", .5)
    d3.select(this)
      .filter(function(d) {
        return data.get(d.id);
      })
      .transition()
      .duration(ANIMATION_SPEED)
      .style("opacity", 1)
      .style("stroke", "gray")
    set_selected_country(d.id);
  }

  let mouseLeaveCountry = function(d) {
    d3.selectAll(".Country")
      .filter(function(d) {
        return data.get(d.id);
      })
      .transition()
      .duration(ANIMATION_SPEED)
      .style("opacity", .8)
    d3.select(this)
      .filter(function(d) {
        return data.get(d.id);
      })
      .transition()
      .duration(ANIMATION_SPEED)
      .style("stroke", "gray")
  }

  let mouseOverHub = function(d) {
    d3.selectAll(".Country")
      .filter(function(d) {
        return data.get(d.id);
      })
      .transition()
      .duration(ANIMATION_SPEED)
      .style("opacity", .5)
    d3.select(this)
      .filter(function(d) {
        return data.get(d.id);
      })
      .transition()
      .duration(ANIMATION_SPEED)
      .style("stroke", "green")
      .style("opacity", .6)
    set_selected_country(d.id);
  }

  let mouseLeaveHub = function(d) {
    d3.selectAll(".Country")
      .filter(function(d) {
        return data.get(d.id);
      })
      .transition()
      .duration(ANIMATION_SPEED)
      .style("opacity", .8)
    d3.select(this)
      .filter(function(d) {
        return data.get(d.id);
      })
      .transition()
      .duration(ANIMATION_SPEED)
      .style("stroke", "red")
      .style("opacity", .4)
  }

  // Draw the map
  svg.append("g")
    .selectAll("path")
    .data(topo.features)
    .enter()
    .append("path")
      // draw each country
      .attr("d", d3.geoPath()
        .projection(projection)
      )
      // set the color of each country
      .attr("fill", function (d) {
        if(SHOW_COLORS){
          var dt = data.get(d.id)
          if (dt){
            var dataset_comlumn = "itPop_" + year;
            if (isNaN(dt[dataset_comlumn])){
              return "black"; // no data available
            }
            return COLOR_SCALE(dt[dataset_comlumn]); // set color scale
          }
        } else {
          return "white";
        }

      })

      .style("stroke", "gray")
      .attr("class", function(d){ return "Country" })
      .style("opacity", .8)
      .on("mouseover", mouseOverCountry )
      .on("mouseleave", mouseLeaveCountry )

      // paint the coutries that are not in the dataset in grey
      d3.selectAll(".Country")
      .filter(function(d) {
        return !data.get(d.id); //check if the country is in the dataset
      })
      .style("fill", "grey");

      // draw circles
      /*if (SHOW_HUBS){
        svg.selectAll("circle")
        .data(topo.features)
        .enter()
          .append("circle").attr("d", d3.geoPath().projection(projection))
            .attr("transform", function(d) {
              if(data.get(d.id)){ // show just the countries in the data base
                let coords = d3.geoPath().projection(projection).centroid(d.geometry);
                return `translate(${coords[0]}, ${coords[1]})`
              }
            })
            .attr("r", "10px")
            .attr("fill", "red")
      }*/

      if (SHOW_HUBS){
        var hubs_year = "hub_" + year;
        svg.selectAll("rect")
        .data(topo.features)
        .enter()
          .append("rect").attr("d", d3.geoPath().projection(projection))
            .attr("transform", function(d) {
              if(data.get(d.id)){ // show just the countries in the data base
                if (!isNaN(data.get(d.id)[hubs_year])){

                  let coords = d3.geoPath().projection(projection).centroid(d.geometry);

                  return `translate(${coords[0]}, ${coords[1]})`
                }
              }
            })
            .attr("x", function(d){
              if(data.get(d.id)){
                if (!isNaN(data.get(d.id)[hubs_year])){
                  let side = data.get(d.id)[hubs_year];
                  return -(scale_size(side)/2);
                }
              }
            })
            .attr("y", function(d){
              if(data.get(d.id)){
                if (!isNaN(data.get(d.id)[hubs_year])){
                  let side = data.get(d.id)[hubs_year];
                  return -(scale_size(side)/2);
                }
              }
            })
            .attr('width', function(d){
              if(data.get(d.id)){
                if (!isNaN(data.get(d.id)[hubs_year])){
                  return scale_size(data.get(d.id)[hubs_year]);
                }
              }
            })
            .attr('height', function(d){
              if(data.get(d.id)){
                if (!isNaN(data.get(d.id)[hubs_year])){
                  return scale_size(data.get(d.id)[hubs_year]);
                }
              }
            })
            .attr('stroke', 'red')
            .attr('fill', 'white')
            .style("opacity", .4)
            .on("mouseover", mouseOverHub )
            .on("mouseleave", mouseLeaveHub )
      }



    }


</script>
